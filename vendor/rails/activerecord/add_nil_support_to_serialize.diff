Index: test/base_test.rb
===================================================================
--- test/base_test.rb	(revision 6007)
+++ test/base_test.rb	(working copy)
@@ -1118,7 +1118,11 @@
 
   def test_serialized_attribute_with_class_constraint
     myobj = MyObject.new('value1', 'value2')
-    topic = Topic.create("content" => myobj)
+    topic = Topic.new
+    assert_nil topic.content
+    
+    topic.content = myobj
+    assert topic.save
     Topic.serialize(:content, Hash)
 
     assert_raise(ActiveRecord::SerializationTypeMismatch) { Topic.find(topic.id).content }
Index: lib/active_record/base.rb
===================================================================
--- lib/active_record/base.rb	(revision 6007)
+++ lib/active_record/base.rb	(working copy)
@@ -574,7 +574,7 @@
 
       # Specifies that the attribute by the name of +attr_name+ should be serialized before saving to the database and unserialized
       # after loading from the database. The serialization is done through YAML. If +class_name+ is specified, the serialized
-      # object must be of that class on retrieval or +SerializationTypeMismatch+ will be raised.
+      # object must be of that class on retrieval, or nil. Otherwise, +SerializationTypeMismatch+ will be raised.
       def serialize(attr_name, class_name = Object)
         serialized_attributes[attr_name.to_s] = class_name
       end
@@ -1958,7 +1958,7 @@
       def unserialize_attribute(attr_name)
         unserialized_object = object_from_yaml(@attributes[attr_name])
 
-        if unserialized_object.is_a?(self.class.serialized_attributes[attr_name])
+        if unserialized_object.is_a?(self.class.serialized_attributes[attr_name]) || unserialized_object.nil?
           @attributes[attr_name] = unserialized_object
         else
           raise SerializationTypeMismatch,
